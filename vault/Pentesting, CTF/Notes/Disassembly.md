![[../FIles/calling conventions.png]]
^^ Il base pointer essenzialmente è ciò che mi permette ad accedere a roba lavorando tramite offset.

![[../FIles/disassembly/disassembly 1.png]]
![[../FIles/disassembly/disassembly 2.png]]
Qui siamo dentro main. si vede, la prima cosa che succede è che viene allocato base pointer.
![[../FIles/disassembly/disassembly 3.png]]
E = extended
R = 64bit
Spesso viene usato solo un pezzo di un indirizzo per salvare byte 

![[../FIles/disassembly/disassembly 4.png]]
Trick usato per mettere i due sullo stesso livello. Da qui in poi, in alto, verrà costruita tutta la mia funzione
![[../FIles/disassembly/disassembly 5.png]]
Decresco l'affare di 16byte. (Visto che sono in architettura a 64 bit, 8 byte hanno due word).

![[../FIles/disassembly/disassembly 6.png]]
-M per scegliere architettura. Intel è la più chiara.

![[../FIles/disassembly/disassembly 7.png]]
Questa roba va sempre guardata, visto che dice da dove inizia il binario.

![[../FIles/disassembly/disassembly 8.png]]
In plt ci sono le informazioni delle funzioni delle librerie.

Sezione .text:
![[../FIles/disassembly/disassembly 9.png]]
Start è messa lì da linux. Quello che fa essenzialmente è chiamare main

Esempio, troviamo una funzione di questo tipo:
![[../FIles/disassembly/disassembly 10.png]]
push rbp, viene mosso stack pointer into base pointer. Dopo vengono sottratti 16byte a stack pointer. Questo perchè dentro questi 16 byte io vado ad allocare le mie variabili locali. Subito dopo vediamo già il comportamento delle calling convenctions: (calloc alloca memoria su heap), dopo per accedere a quella roba usiamo:
![[../FIles/calling conventions.png]] e sappiamo esattamente dove si trovano. (osserva che c'è ebp+8 nella casella, e non +4, perchè dobbiamo scavalcare il return pointer).

Quindi, sapendo che calloc prende quelle due robe e che gli apsso gli argomenti con i due mov messi lì sopra, io so che il programmatore sta passando a quella funzione esattamente quella roba lì.

Osserva che le funzioni della stdlib della c mettono il loro valore di ritorno dentro rax/eax
118c: sta spostando il valore di ritorno nella prima variabile.
(QWORD PTR == "a questo indirizzo")

`ltrace`, `strace`
`ltrace` mostra la tracciatura delle chiamate di libreria che effettua il binario.
`strace` mostra le chiamate al sistema

![[../FIles/disassembly/disassembly 11.png]]
^^ questo fa uscire con valore 1.


todo installa ghidra