Alcuni algoritmi SHA (più precisamente, gli algoritmi basati sulla costruzione [Merkle-Damgård](https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction)) hanno una vulnerabilità che permette di _estendere_ (con _valori arbitrari_ + padding) il plaintext un hash di un valore sconosciuto e ottenere un valore conosciuto.
Questa repo spiega bene come usare questa cosa:
https://github.com/stephenbradshaw/hlextend

Praticamente: supponiamo che io ho una certa funzione di hash del tipo
```python
assert len(SALT) == 10
hash = SHA1(SALT + b"hello")
print(hash)
# 52e98441017043eee154a6d1af98c5e0efab055c
```
dove `SALT` è un valore sconosciuto ma di lunghezza conosciuta (o perlomeno guessabile), io posso usare questo codice:
```python
import hlextend
sha = hlextend.new('sha1')
print sha.extend('file', 'hello', 10, '52e98441017043eee154a6d1af98c5e0efab055c')
print sha.hexdigest()
# 'hello\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00xfile'
# c60fa7de0860d4048a3bfb36b70299a95e6587c9
```
per ottenere una stringa che, se inserita nella funzione hash al posto di `b"hello"` mi farà uscire un hash noto (`c60...`).

Il modulo usato è scritto in `python2`, quindi è un po' scomodo da usare, ma funziona ancora. Un giochetto stupido per farlo funzionare è:
```python
ext = sha.extend( ... )
ext = eval("b\"" + eval('ext') + "\"")
```
In questo modo `ext` saranno `bytes` formattati correttamente.