### Vantaggi della crittografia *a*simmetrica
![[../FIles/rsa.png]]
![[../FIles/Pasted image 20220405175302.png]]

[[../../Teoria dei Numeri/Trapdoor Functions]]
[[Aritmetica modulare]]
Trapdoor usata in RSA: [[Esponenziazione modulare]]

Faremo uso di [[../../Teoria dei Numeri/Mod inv]].

[[Piccolo teorema di Fermat]]: ogni numero è scritto come prodotto di primi

[[Numeri coprimi]]


### Importanza di $\varphi$
Eulero dimostra una proprietà di [[Funzione toziente]] molto utile per usare RSA

### Textbook RSA
![[../FIles/Crypto/Pasted image 20220405180845.png]]
RSA è difficile da rompere perchè noi dobbiamo _fattorizzare numeri molto grandi_.

##### `DEF` Chiave pubblica
![[../FIles/Crypto/Pasted image 20220405181058.png]]

##### `DEF` Chiave privata
![[../FIles/Crypto/Pasted image 20220405181103 1.png]]
La proprietà importante della chiave privata è che:
$$
e \cdot d \mod \varphi(n) = 1
$$
(Correlata col modo in cui definiamo $d$)

#### Funzionamento di RSA
![[../FIles/Crypto/Pasted image 20220405181539.png]]

##### Perché funziona?
Vale il [[../../Teoria dei Numeri/Teorema di Eulero]]. Le operazioni che andiamo a fare sono quindi:
![[../FIles/Crypto/Pasted image 20220405181845.png]]
Con Eulero sfruttiamo il fatto che m elevato alla phi di m = 1 (visto che tutte queste operazioni vengono fatte in una classe modulo n)

Implementazione più usata:
#### RSA-CRT
Sfrutta il [[Teorema del Resto Cinese]]. In pratica quello che si fa è:
1) Si fissa $e = 0\texttt x 10001 = 65537$ in modo che sia facile da usare.
2) La funzione di decrypt sfrutta l'ottimizzazione usando il [[Teorema del Resto Cinese|CRT]]

### Firma con RSA
![[../FIles/Pasted image 20220405182925.png]]
![[../FIles/Pasted image 20220405183135.png]]
Se io prendo un messaggio e lo _cifro con la mia chiave privata_ e lo spedisco, poi chi lo riceve può _usare la mia chiave pubblica_ per vedere il messaggio ricevuto. Ha senso perché in questo modo _solo io sono in grado di firmare il messaggio_.

La firma sfrutta un Hash e una doppia coppia chiave pub-priv (una posseduta da uno e l'altra da un altro).
![[../FIles/Pasted image 20220405183224.png]]
Ora, in generale, _non bisogna mai riusare le stesse chiavi_ (per cifra e signature, ma anche in generale).

Implementazione più usata:
#### ECDSA

### RSA attacks
![[../FIles/Pasted image 20220405183909.png]]
Prime factorization: "sempre" possibile; è un attacco bruteforce. Non si riesce a fare per primi molto grandi. Se prendiamo dei primi piccoli/primi vicini fra loro/quadrato dei primi... possiamo farlo "facilmente".

Common prime: se diversi numeri hanno primi in comune, l'algoritmo per calcolare gcd è veloce.

Common modulus: se abbiamo due chiavi dove cambia esponente, la vulnerabilità si ha perchè abbiamo informazioni su esponente e possiamo fattorizzare... dettagli.